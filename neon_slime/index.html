<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Jelly Slime - Matter.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0d0d0d;
        }

        canvas {
            display: block;
        }

        #instruction {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #00ffaa;
            font-family: 'Verdana', sans-serif;
            pointer-events: none;
            text-shadow: 0 0 10px #00ffaa;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>

<body>
    <div id="instruction">Drag the Jelly! â€¢ Soft Body Physics</div>
    <script>
        // Module Aliases
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Composites = Matter.Composites,
            Common = Matter.Common,
            MouseConstraint = Matter.MouseConstraint,
            Mouse = Matter.Mouse,
            Composite = Matter.Composite,
            Bodies = Matter.Bodies,
            Body = Matter.Body,
            Events = Matter.Events;

        // --- Setup ---
        const engine = Engine.create();
        const world = engine.world;

        // Create Renderer
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false, // We will do custom rendering anyway later if needed, but standard handles colors too
                background: '#0d0d0d',
                pixelRatio: window.devicePixelRatio
            }
        });

        // --- Soft Body (The Slime) ---
        const particleOptions = {
            friction: 0.05,
            frictionStatic: 0.1,
            render: { visible: true, fillStyle: '#00ffaa' }
        };

        const constraintOptions = {
            stiffness: 0.1, // Elastic
            render: { type: 'line', strokeStyle: '#00ffaa', lineWidth: 2 } // Visible Mesh
        };

        // Create a 5x5 Grid of particles (Soft Body)
        // xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions
        const slimeWidth = 5;
        const slimeHeight = 5;
        const startX = window.innerWidth / 2 - 100;
        const startY = window.innerHeight / 2 - 100;

        const slime = Composites.softBody(
            startX, startY,
            slimeWidth, slimeHeight,
            0, 0,
            true, // crossBrace for structure stability
            15,   // radius
            particleOptions,
            constraintOptions
        );

        // Make the outer particles slightly heavier/bigger to form a skin? 
        // Or just let it be uniform.
        // Let's customize the visual style of constraints to be neon
        slime.constraints.forEach(c => {
            c.render.strokeStyle = 'rgba(0, 255, 170, 0.4)';
            c.render.lineWidth = 1;
        });

        // Add to world
        Composite.add(world, slime);

        // --- Walls ---
        const wallOptions = {
            isStatic: true,
            render: { fillStyle: '#222' }
        };
        const width = window.innerWidth;
        const height = window.innerHeight;
        const thickness = 50;

        Composite.add(world, [
            Bodies.rectangle(width / 2, -thickness / 2, width, thickness, wallOptions), // Top
            Bodies.rectangle(width / 2, height + thickness / 2, width, thickness, wallOptions), // Bottom
            Bodies.rectangle(width + thickness / 2, height / 2, thickness, height, wallOptions), // Right
            Bodies.rectangle(-thickness / 2, height / 2, thickness, height, wallOptions) // Left
        ]);

        // --- Mouse Control ---
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.1,
                render: {
                    visible: false
                }
            }
        });
        Composite.add(world, mouseConstraint);
        render.mouse = mouse;

        // Audio Triggers for Drag
        Events.on(mouseConstraint, 'startdrag', () => {
            if (SoundManager && SoundManager.ctx) {
                SoundManager.playTouch();
            }
        });
        Events.on(mouseConstraint, 'enddrag', () => {
            if (SoundManager && SoundManager.ctx) {
                if (SoundManager && SoundManager.ctx) {
                    // SoundManager.stopStretch(); // Disabled
                    SoundManager.playThrow();
                }
            }
        });

        // --- Custom Render Loop (For Glow Effects) ---
        // We use Matter.Render for basics, but let's hook into `afterRender` to add Glow
        Events.on(render, 'afterRender', function () {
            const ctx = render.context;

            // Draw Glow
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            // Draw constraints (The Mesh)
            const bodies = Composite.allBodies(slime);
            const constraints = Composite.allConstraints(slime);

            ctx.beginPath();
            constraints.forEach(c => {
                if (c.bodyA && c.bodyB) {
                    ctx.moveTo(c.bodyA.position.x, c.bodyA.position.y);
                    ctx.lineTo(c.bodyB.position.x, c.bodyB.position.y);
                }
            });
            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ffaa';
            ctx.stroke();

            // Draw Nodes (Particles)
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ccffdd';
            ctx.fillStyle = '#00ffaa';

            bodies.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        });

        // --- Sound Manager ---
        const SoundManager = {
            ctx: null,
            isMuted: true,
            droneNodes: [],

            init: function () {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.isMuted = false;
                console.log("Slime Audio Initialized");
            },

            createOsc: function (type, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                return osc;
            },

            createGain: function (val) {
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(val, this.ctx.currentTime);
                return gain;
            },

            // 1. Goo Ambient (LFO Drone) - DISABLED per user feedback
            // startAmbient: function() { ... }

            // 2. Impact (Heavy Thud "Kung")

            // 2. Impact (Heavy Thud "Kung")
            playImpact: function () {
                if (this.isMuted || !this.ctx) return;
                const t = this.ctx.currentTime;

                // Kick Drum Style
                const osc = this.createOsc('sine', 150);
                const gain = this.createGain(0.3); // Heavy but controlled

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start(t);
                osc.stop(t + 0.15); // Short punch

                // Frequency Drop (Kick)
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.15);

                // Volume Envelope
                gain.gain.setValueAtTime(1.0, t); // Impact louder than Touch (was 0.3, Touch is 0.4)
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            },

            // 4. Touch (Short "Boop") - Cheerful start
            playTouch: function () {
                if (this.isMuted || !this.ctx) return;
                const t = this.ctx.currentTime;

                const osc = this.createOsc('sine', 600);
                const gain = this.createGain(0.1);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start(t);
                osc.stop(t + 0.1);

                osc.frequency.exponentialRampToValueAtTime(800, t + 0.05);
                gain.gain.setValueAtTime(0.4, t); // Boosted (was 0.1)
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            },

            // 5. Stretch (Continuous while dragging) - DISABLED per user feedback
            // playStretch: function() { ... } 
            // stopStretch: function() { ... }

            stopStretch: function () {
                // Kept as shim if needed, or remove caller logic
            },

            // 6. Throw (Whoosh noise)
            playThrow: function () {
                if (this.isMuted || !this.ctx) return;
                const t = this.ctx.currentTime + 0.1; // Delayed start by 0.1s per user request

                const bufferSize = this.ctx.sampleRate * 1.0; // 1.0s buffer (was 0.5s, too short for 0.7s play)
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.Q.value = 5; // Whistling (Sharp)

                const gain = this.createGain(0.8); // Louder (was 0.6)

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                // Sweep filter down (High Hwi-ik)
                filter.frequency.setValueAtTime(3500, t); // Start high (lowered from 4000 for audibility)
                filter.frequency.exponentialRampToValueAtTime(200, t + 0.6); // Longer sweep

                gain.gain.setValueAtTime(3.0, t); // Massive Boost (was 0.8)
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);

                noise.start(t);
                noise.stop(t + 0.7);
            },

            // 3. Wake
            playWake: function () {
                if (this.isMuted || !this.ctx) return;
                const t = this.ctx.currentTime;

                const osc = this.createOsc('square', 220); // A3
                const gain = this.createGain(0);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(220, t);
                filter.frequency.exponentialRampToValueAtTime(2000, t + 0.1);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start(t);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.1, t + 0.05);
                gain.gain.linearRampToValueAtTime(0, t + 0.2);

                osc.stop(t + 0.2);
            }
        };

        // --- Silent Audio Wake + UI ---
        const audioStatus = document.createElement('div');
        // Neon Green
        audioStatus.style.cssText = 'position:fixed;bottom:20px;right:20px;font-size:12px;color:#fff;background:rgba(0,0,0,0.8);padding:8px 15px;border-radius:4px;letter-spacing:1px;z-index:99999;font-family:sans-serif;pointer-events:none;border:1px solid #00ffaa;box-shadow: 0 0 10px rgba(0, 255, 170, 0.3);';
        audioStatus.innerText = 'AUDIO: OFFLINE [TOUCH]';
        document.body.appendChild(audioStatus);

        const wakeAudio = () => {
            let contextResumed = false;

            if (!SoundManager.ctx) {
                SoundManager.init();
                contextResumed = true;
            } else if (SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
                contextResumed = true;
            }

            if (SoundManager.ctx && (SoundManager.ctx.state === 'running' || contextResumed)) {
                audioStatus.innerText = 'AUDIO: ONLINE';
                audioStatus.style.borderColor = '#00ffaa';
                audioStatus.style.boxShadow = '0 0 15px rgba(0, 255, 170, 0.5)';
                audioStatus.style.color = '#00ffaa';

                SoundManager.playWake();

                ['click', 'touchstart', 'keydown'].forEach(evt =>
                    document.removeEventListener(evt, wakeAudio)
                );
            }
        };

        ['click', 'touchstart', 'keydown'].forEach(evt =>
            document.addEventListener(evt, wakeAudio)
        );

        // --- Run ---
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        Events.on(engine, 'collisionStart', function (event) {
            if (SoundManager && SoundManager.ctx) {
                const pairs = event.pairs;
                let maxImpact = 0;
                let hitsWall = false;

                // Check collisions
                for (let i = 0; i < pairs.length; i++) {
                    const pair = pairs[i];
                    // Only care if we hit a static object (Wall/Floor)
                    if (pair.bodyA.isStatic || pair.bodyB.isStatic) {
                        const speedA = pair.bodyA.speed || 0;
                        const speedB = pair.bodyB.speed || 0;
                        const impact = Math.max(speedA, speedB);

                        if (impact > maxImpact) maxImpact = impact;
                        hitsWall = true;
                    }
                }

                // Threshold: 2.0 (Lowered from 3.0 to catch soft drops)
                // Must hit wall/floor
                if (hitsWall && maxImpact > 1.5) {
                    const now = SoundManager.ctx.currentTime;
                    // 300ms Throttle 
                    if (!SoundManager.lastBounceTime || now - SoundManager.lastBounceTime > 0.3) {
                        SoundManager.playImpact();
                        SoundManager.lastBounceTime = now;
                    }
                }
            }
        });

        // --- Resize Handling ---
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;
            // Re-create walls if needed, but for simplicity we rely on the center mostly
        });

    </script>
</body>

</html>