<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Velvet Cloth Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a0505;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #87CEEB;
            /* Sky Blue */
            font-family: 'Helvetica', sans-serif;
            pointer-events: none;
            text-align: center;
            opacity: 0.8;
            font-weight: lighter;
            z-index: 10;
        }

        #instructions input,
        #instructions button,
        #instructions label {
            pointer-events: auto;
        }

        /* Hue Slider Visibility Fix */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
            outline: none;
            border: 1px solid rgba(135, 206, 235, 0.3);
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: #87CEEB;
            /* Sky Blue Thumb */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(135, 206, 235, 0.5);
        }
    </style>
</head>

<body>
    <div id="instructions">
        <h2>Velvet Cloth</h2>
        <p>Drag to Tear â€¢ Shift + Drag to Cut</p>
        <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center; align-items: center;">
            <label style="font-size: 12px;">Hue:</label>
            <input type="range" id="hueSlider" min="0" max="360" value="145" style="cursor: pointer;">
            <button id="resetBtn"
                style="background:none; border: 1px solid #87CEEB; color: #87CEEB; padding: 5px 10px; cursor: pointer; font-family: inherit; border-radius: 4px; transition: all 0.2s;">Reset</button>
        </div>
        <input type="color" id="colorPicker" value="#8a1c1c" style="display:none;">
        <!-- Hidden, using Hue slider instead for 'slider' request -->
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const hueSlider = document.getElementById('hueSlider');
        const resetBtn = document.getElementById('resetBtn');

        let width, height;
        let clothColor = 'hsl(145, 80%, 33%)'; // Initial Green

        hueSlider.addEventListener('input', (e) => {
            // Keep saturation and lightness fixed for velvet look, just change Hue
            clothColor = `hsl(${e.target.value}, 80%, 33%)`;
            // Also update background tint slightly? No, keep it dark.
        });

        resetBtn.addEventListener('click', () => {
            init();
        });

        // Configuration (Base)
        const physicsAccuracy = window.innerWidth < 768 ? 2 : 4; // Reduced for performance
        const mouseInfluence = 40; // Halved for more precision
        const tearDistance = 150; // Toughened fabric (harder to rip)
        const gravity = 1200;
        const clothY = 160;
        let spacing = 12;
        let widthPoints = 60;
        let heightPoints = 40;
        const windStrength = 15;

        // State
        const points = [];
        const constraints = [];
        let mouse = { x: 0, y: 0, down: false, button: 0, shiftKey: false, draggedPoints: [] };

        // --- Sound Manager ---
        const SoundManager = {
            ctx: null,
            isMuted: true,
            droneNodes: [],

            init: function () {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.isMuted = false;
                this.startAmbient();
                console.log("Velvet Audio Initialized");
            },

            createOsc: function (type, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                return osc;
            },

            createGain: function (val) {
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(val, this.ctx.currentTime);
                return gain;
            },

            // 1. Cloth Wind/Flutter Ambient
            startAmbient: function () {
                if (this.isMuted) return;
                const t = this.ctx.currentTime;

                // Pink Noise buffer for "Wind"
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                let lastOut = 0; // Fix: Initialize BEFORE loop
                
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5; 
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                const noiseGain = this.createGain(0.2); // Boosted from 0.05

                // LFO to modulate filter (wind gust)
                const lfo = this.createOsc('sine', 0.2);
                const lfoGain = this.createGain(200);

                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);

                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);

                noise.start(t);
                lfo.start(t);

                this.droneNodes.push(noise, lfo);
            },

            // 2. Tear Sound (Ripping Fabric)
            playTear: function () {
                if (this.isMuted || !this.ctx) return;
                const t = this.ctx.currentTime;

                // Noise burst
                const bufferSize = this.ctx.sampleRate * 0.1;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 800;

                const gain = this.createGain(0.3); // Boosted from 0.1 for louder snap
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start(t);
            },

            // 3. Cut Sound (Sharp Snip)
            playCut: function () {
                if (this.isMuted || !this.ctx) return;
                const t = this.ctx.currentTime;

                const osc = this.createOsc('triangle', 600);
                const gain = this.createGain(0.25); // Boosted from 0.1

                osc.frequency.setValueAtTime(600, t);
                osc.frequency.exponentialRampToValueAtTime(1200, t + 0.05); // Zip up

                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.05);
            },

            // 4. Wake
            playWake: function () {
                if (this.isMuted || !this.ctx) return;
                const t = this.ctx.currentTime;

                const osc = this.createOsc('sine', 220);
                const gain = this.createGain(0);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start(t);

                osc.frequency.setValueAtTime(220, t);
                osc.frequency.setValueAtTime(440, t + 0.2);

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.1, t + 0.1);
                gain.gain.linearRampToValueAtTime(0, t + 0.5);

                osc.stop(t + 0.5);
            }
        };

        // --- Silent Audio Wake + UI ---
        const audioStatus = document.createElement('div');
        // Sky Blue Theme
        audioStatus.style.cssText = 'position:fixed;bottom:20px;right:20px;font-size:12px;color:#fff;background:rgba(0,0,0,0.8);padding:8px 15px;border-radius:4px;letter-spacing:1px;z-index:99999;font-family:Helvetica, sans-serif;pointer-events:none;border:1px solid #87CEEB;box-shadow: 0 0 10px rgba(135, 206, 235, 0.3);';
        audioStatus.innerText = 'AUDIO: OFFLINE [TOUCH]';
        document.body.appendChild(audioStatus);

        const wakeAudio = () => {
            let contextResumed = false;

            if (!SoundManager.ctx) {
                SoundManager.init();
                contextResumed = true;
            } else if (SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
                contextResumed = true;
            }

            if (SoundManager.ctx && (SoundManager.ctx.state === 'running' || contextResumed)) {
                audioStatus.innerText = 'AUDIO: ONLINE';
                audioStatus.style.borderColor = '#87CEEB';
                audioStatus.style.boxShadow = '0 0 15px rgba(135, 206, 235, 0.5)';
                audioStatus.style.color = '#87CEEB';

                SoundManager.playWake();

                ['click', 'touchstart', 'keydown'].forEach(evt =>
                    document.removeEventListener(evt, wakeAudio)
                );
            }
        };

        ['click', 'touchstart', 'keydown'].forEach(evt =>
            document.addEventListener(evt, wakeAudio)
        );

        // --- Vector Helper ---
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.oldx = x;
                this.oldy = y;
                this.pinned = false;
            }

            update(delta) {
                if (this.pinned) return;

                // If being dragged, stay attached to mouse with original offset
                const dragged = mouse.draggedPoints.find(dp => dp.point === this);
                if (dragged) {
                    this.oldx = this.x;
                    this.oldy = this.y;
                    this.x = mouse.x + dragged.offsetX;
                    this.y = mouse.y + dragged.offsetY;
                    return;
                }

                const vx = (this.x - this.oldx) * 0.99;
                const vy = (this.y - this.oldy) * 0.99;

                this.oldx = this.x;
                this.oldy = this.y;

                this.x += vx;
                this.y += vy;
                this.y += gravity * delta * delta;

                const wind = Math.sin(Date.now() / 500 + this.y * 0.05) * windStrength +
                    Math.cos(Date.now() / 1200) * (windStrength * 0.5);

                this.x += wind * delta * delta;

                if (this.y > height) {
                    this.y = height;
                    this.oldy = this.y + vy * 0.5;
                }
            }

            draw() {
                // Not drawing points, only constraints
            }
        }

        class Constraint {
            constructor(p1, p2) {
                this.p1 = p1;
                this.p2 = p2;
                this.length = spacing;
            }

            resolve() {
                if (!this.p1 || !this.p2) return;

                const dx = this.p1.x - this.p2.x;
                const dy = this.p1.y - this.p2.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > tearDistance) {
                    this.p1 = null;
                    if (SoundManager && SoundManager.ctx) SoundManager.playTear();
                    return;
                }

                if (dist > this.length) {
                    const diff = (this.length - dist) / dist;
                    const offsetX = dx * diff * 0.5;
                    const offsetY = dy * diff * 0.5;

                    if (!this.p1.pinned && mouse.draggedPoint !== this.p1) {
                        this.p1.x += offsetX;
                        this.p1.y += offsetY;
                    }
                    if (!this.p2.pinned && mouse.draggedPoint !== this.p2) {
                        this.p2.x -= offsetX;
                        this.p2.y -= offsetY;
                    }
                }
            }

            draw() {
                // Constraint drawing is now handled in batches in the main loop
            }
        }

        // --- Init ---
        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            // Responsive Scaling
            spacing = width < 768 ? 8 : 10; // Denser on mobile
            const targetWidth = width < 768 ? width * 0.85 : 700; // 85% width on mobile
            widthPoints = Math.floor(targetWidth / spacing);
            // Height: fill about 70-80% of screen height
            heightPoints = width < 768 ? Math.floor((height * 0.7) / spacing) : 45;

            points.length = 0;
            constraints.length = 0;

            const startX = (width - widthPoints * spacing) / 2;

            // Create Points
            for (let y = 0; y < heightPoints; y++) {
                for (let x = 0; x < widthPoints; x++) {
                    const p = new Point(startX + x * spacing, clothY + y * spacing);
                    // Pin the top row
                    if (y === 0) {
                        p.pinned = true;
                    }
                    points.push(p);
                }
            }

            // Create Constraints (Grid)
            for (let y = 0; y < heightPoints; y++) {
                for (let x = 0; x < widthPoints; x++) {
                    if (x < widthPoints - 1) {
                        const c = new Constraint(points[y * widthPoints + x], points[y * widthPoints + x + 1]);
                        c.spacing = spacing;
                        constraints.push(c);
                    }
                    if (y < heightPoints - 1) {
                        const c = new Constraint(points[y * widthPoints + x], points[(y + 1) * widthPoints + x]);
                        c.spacing = spacing;
                        constraints.push(c);
                    }
                }
            }
        }

        // --- Interaction Logic ---
        function handleStart(x, y, button, shift) {
            mouse.down = true;
            mouse.x = x;
            mouse.y = y;
            mouse.button = button;
            mouse.shiftKey = shift;

            if (button === 2 || shift) return; // Right click or Shift is for cutting

            // Grab all points within influence radius
            mouse.draggedPoints = [];
            for (let p of points) {
                const dx = x - p.x;
                const dy = y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < mouseInfluence) {
                    mouse.draggedPoints.push({
                        point: p,
                        offsetX: p.x - x,
                        offsetY: p.y - y
                    });
                }
            }
        }

        function handleMove(x, y, shift) {
            mouse.x = x;
            mouse.y = y;
            mouse.shiftKey = shift;
        }

        function handleEnd() {
            mouse.down = false;
            mouse.draggedPoints = [];
        }

        function updateInteraction() {
            // 1. Magnetic Hover Force (Feels great on Trackpads/Mobile)
            // Even without clicking, the cloth ripples as you move near it
            const hoverRadius = 80;
            const hoverStrength = 0.3;

            for (let p of points) {
                if (p.pinned) continue;
                const dx = mouse.x - p.x;
                const dy = mouse.y - p.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < hoverRadius * hoverRadius) {
                    const dist = Math.sqrt(distSq);
                    const force = (1 - dist / hoverRadius) * hoverStrength;
                    // Apply a gentle push away/pull based on movement
                    p.x -= dx * force * 0.1;
                    p.y -= dy * force * 0.1;
                }
            }

            // 2. Cut logic (Right Click OR Shift + Drag)
            if (mouse.down && (mouse.button === 2 || mouse.shiftKey)) {
                for (let c of constraints) {
                    if (!c.p1) continue;
                    const midX = (c.p1.x + c.p2.x) / 2;
                    const midY = (c.p1.y + c.p2.y) / 2;
                    const dx = mouse.x - midX;
                    const dy = mouse.y - midY;
                    if (dx * dx + dy * dy < 200) {
                        if (c.p1) SoundManager.playCut();
                        c.p1 = null;
                    }
                }
            }
        }

        // --- Loop ---
        function update(delta) {
            // Physics Points
            for (let i = 0; i < points.length; i++) {
                points[i].update(delta);
            }

            // Constraints Relax (Iterate multiples for stiffness)
            for (let i = 0; i < physicsAccuracy; i++) {
                for (let c = 0; c < constraints.length; c++) {
                    if (constraints[c].p1) constraints[c].resolve();
                }
            }
            updateInteraction();
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // 1. Prepare Color Bins for Batch Rendering (HUGE performance boost)
            const baseHue = parseInt(hueSlider.value);
            const numBins = 6;
            const bins = Array.from({ length: numBins }, () => []);

            for (let i = 0; i < constraints.length; i++) {
                const c = constraints[i];
                if (!c.p1 || !c.p2) continue;

                // Fast tension calc
                const dx = c.p1.x - c.p2.x;
                const dy = c.p1.y - c.p2.y;
                const distSq = dx * dx + dy * dy;
                const baseSq = c.spacing * c.spacing;

                // Tension bin (0 to numBins-1)
                let binIdx = Math.floor((distSq - baseSq) / 100);
                binIdx = Math.max(0, Math.min(binIdx, numBins - 1));
                bins[binIdx].push(c);
            }

            // 2. Render each bin in one stroke call
            ctx.lineWidth = 1;
            for (let b = 0; b < numBins; b++) {
                if (bins[b].length === 0) continue;

                const lightness = 33 + (b * (40 / (numBins - 1)));
                ctx.strokeStyle = `hsl(${baseHue}, 80%, ${lightness}%)`;

                ctx.beginPath();
                for (let c of bins[b]) {
                    ctx.moveTo(c.p1.x, c.p1.y);
                    ctx.lineTo(c.p2.x, c.p2.y);
                }
                ctx.stroke();
            }

            // Draw Interaction Cursor
            if (mouse.down) {
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, mouseInfluence, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(135, 206, 235, 0.1)';
                ctx.fill();
                ctx.strokeStyle = mouse.shiftKey ? 'rgba(255, 255, 255, 0.8)' : 'rgba(135, 206, 235, 0.4)';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        let lastTime = Date.now();
        function loop() {
            const now = Date.now();
            const delta = (now - lastTime) / 1000; // Seconds
            lastTime = now;

            // Cap delta to prevent explosion on lag
            update(Math.min(delta, 0.02));
            draw();
            requestAnimationFrame(loop);
        }

        // --- Events ---
        window.addEventListener('resize', init);

        // Mouse Events
        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY, e.button, e.shiftKey));
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY, e.shiftKey));
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Key Events (Update shift status even if mouse doesn't move)
        window.addEventListener('keydown', e => { if (e.key === 'Shift') mouse.shiftKey = true; });
        window.addEventListener('keyup', e => { if (e.key === 'Shift') mouse.shiftKey = false; });

        // Touch Events (for Pads/Tablets/Mobiles)
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            handleStart(e.touches[0].clientX, e.touches[0].clientY, 0);
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        canvas.addEventListener('touchend', handleEnd);

        init();
        loop();

    </script>
</body>

</html>