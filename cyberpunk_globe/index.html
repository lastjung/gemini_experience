<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Globe - Interactive 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #0ff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px #0ff;
        }
    </style>
    <!-- Import Map for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">Cyberpunk Wireframe Globe<br>Drag to Rotate â€¢ Scroll to Zoom</div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            globeRadius: 10,
            globeSegments: 32,
            beaconCount: 15,
            beaconColor: 0x00ffff, // Neon Blue
            wireframeColor: 0x2244ff, // Darker Blue
            backgroundColor: 0x020205,
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.backgroundColor, 0.02);
        scene.background = new THREE.Color(CONFIG.backgroundColor);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(25, 15, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance opt
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- Orbit Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 15;
        controls.maxDistance = 60;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8; // Faster rotation

        // --- Post-Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, 0.4, 0.85
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0; // Stronger Bloom
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Objects: 1. Stars ---
        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const count = 3000;
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 300;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ size: 0.2, color: 0x4444ff, transparent: true, opacity: 0.6 });
            return new THREE.Points(geometry, material);
        }
        scene.add(createStars());

        // --- Objects: 2. Core Globe (Dark Matter) ---
        const coreGeo = new THREE.SphereGeometry(9.5, 32, 32);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const core = new THREE.Mesh(coreGeo, coreMat);
        scene.add(core);

        // --- Objects: 3. Hex/Geodesic Shield (Scanning Effect) ---
        // Back to Sphere for "Globe" look
        const shieldGeo = new THREE.SphereGeometry(10, 32, 32);

        // Custom Shader for "Scanning" Shield
        const shieldMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x00ffff) },
                uScanColor: { value: new THREE.Color(0x39FF14) } // Neon Green
            },
            vertexShader: `
                varying vec3 vPos;
                varying vec2 vUv;
                void main() {
                    vPos = position;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                uniform vec3 uScanColor;
                varying vec3 vPos;

                void main() {
                    // Basic Grid/Wireframe logic is hard in frag shader without barycentric coords.
                    // Instead, we rely on the geometry being drawn as wireframe or use points.
                    // Wait, let's use Three.js WireframeGeometry for lines, and this mesh for "Surface Shield" effect.
                    
                    // Animated Scanline
                    float scan = mod(uTime * 5.0 - vPos.y + 10.0, 20.0);
                    float scanWidth = 2.0;
                    float intensity = 0.0;
                    
                    if (scan < scanWidth) {
                        intensity = 1.0 - smoothstep(0.0, scanWidth, scan);
                    }

                    // Hex-like pattern (fake) using sine waves on position
                    float grid = step(0.98, sin(vPos.x * 2.0) * sin(vPos.y * 2.0) * sin(vPos.z * 2.0));
                    
                    vec3 finalColor = mix(uColor * 0.1, uScanColor, intensity * 0.5);
                    float alpha = 0.1 + intensity * 0.4 + grid * 0.2;
                    
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        // Combine Wireframe and Shader Surface
        const shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
        scene.add(shieldMesh);

        // Explicit Wireframe Overlay
        const wireGeo = new THREE.WireframeGeometry(shieldGeo);
        const wireMat = new THREE.LineBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.15 });
        const wireMesh = new THREE.LineSegments(wireGeo, wireMat);
        scene.add(wireMesh);

        // --- Objects: 4. Orbital Rings (Network) ---
        const rings = [];
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });

        function createRing(radius, tube, inclination) {
            const geometry = new THREE.TorusGeometry(radius, tube, 2, 100);
            const mesh = new THREE.Mesh(geometry, ringMat);
            mesh.rotation.x = Math.PI / 2; // Flat
            mesh.rotation.y = inclination;

            // Add a "Data Packet" moving on the ring?
            // Simplified: The ring itself rotates
            scene.add(mesh);
            rings.push({ mesh: mesh, speed: (Math.random() - 0.5) * 2.0, axis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize() });
        }

        createRing(12, 0.05, 0.5);
        createRing(14, 0.03, -0.5);
        createRing(16, 0.02, 0.2);

        // --- Objects: 5. Data Connections (Arcs) ---
        const arcs = [];

        function createArc() {
            // Pick 2 random points on sphere
            const r = 10;
            const p1 = new THREE.Vector3().setFromSphericalCoords(r, Math.acos(2 * Math.random() - 1), 2 * Math.PI * Math.random());
            const p2 = new THREE.Vector3().setFromSphericalCoords(r, Math.acos(2 * Math.random() - 1), 2 * Math.PI * Math.random());

            // Validate distance (don't connect too close or too far)
            if (p1.distanceTo(p2) < 5) return;

            // Bezier Control points (popping out)
            const mid = p1.clone().add(p2).multiplyScalar(0.5).normalize().multiplyScalar(r * 1.5); // 1.5x height

            const curve = new THREE.QuadraticBezierCurve3(p1, mid, p2);
            const pts = curve.getPoints(20);
            const geometry = new THREE.BufferGeometry().setFromPoints(pts);

            // Light Orange for complementary contrast
            const material = new THREE.LineBasicMaterial({ color: 0xFFB366, transparent: true, opacity: 0 });
            const line = new THREE.Line(geometry, material);

            scene.add(line);

            arcs.push({
                line: line,
                life: 0,
                speed: 0.5 + Math.random(),
                maxLife: 100 // frames
            });
        }

        // --- Objects: 6. Surface Markers (Hex Nodes) ---
        const nodes = [];
        const nodeGeo = new THREE.CircleGeometry(0.2, 6);
        const nodeMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        for (let i = 0; i < 20; i++) {
            const mesh = new THREE.Mesh(nodeGeo, nodeMat);
            const r = 10.1; // Just above surface
            const pos = new THREE.Vector3().setFromSphericalCoords(r, Math.acos(2 * Math.random() - 1), 2 * Math.PI * Math.random());
            mesh.position.copy(pos);
            mesh.lookAt(0, 0, 0); // Align to center
            scene.add(mesh);
            nodes.push({ mesh: mesh, blinkOffset: Math.random() * 10 });
        }


        // --- Animation ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            controls.update();

            // 1. Animate Shield Shader
            shieldMat.uniforms.uTime.value = time;

            // 2. Animate Rings
            rings.forEach(r => {
                r.mesh.rotateOnAxis(r.axis, r.speed * 0.01);
            });

            // 3. Animate Data Arcs (Spawn and Fade)
            // Increased spawn rate significantly
            if (Math.random() < 0.1) createArc(); // Spawn chance

            for (let i = arcs.length - 1; i >= 0; i--) {
                const a = arcs[i];
                a.life++;

                // Opacity curve: Fade In -> Fade Out
                const progress = a.life / a.maxLife;
                const opacity = Math.sin(progress * Math.PI); // 0 -> 1 -> 0
                a.line.material.opacity = opacity;

                if (a.life > a.maxLife) {
                    scene.remove(a.line);
                    arcs.splice(i, 1);
                }
            }

            // 4. Animate Nodes (Blink)
            nodes.forEach(n => {
                const s = 1 + Math.sin(time * 5 + n.blinkOffset) * 0.5;
                n.mesh.scale.setScalar(s);
            });

            composer.render();
        }

        // --- Resize Handler ---
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();
    </script>
</body>

</html>