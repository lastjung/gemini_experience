<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Globe - Interactive 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #0ff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px #0ff;
        }
    </style>
    <!-- Import Map for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">Cyberpunk Wireframe Globe<br>Drag to Rotate â€¢ Scroll to Zoom</div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            globeRadius: 10,
            globeSegments: 32,
            beaconCount: 15,
            beaconColor: 0x00ffff, // Neon Blue
            wireframeColor: 0x2244ff, // Darker Blue
            backgroundColor: 0x020205,
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.backgroundColor, 0.02);
        scene.background = new THREE.Color(CONFIG.backgroundColor);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // ... updateCameraPosition will handle main camera ...

        function updateCameraPosition() {
            if (window.innerWidth < 768) {
                camera.position.set(40, 25, 40);
            } else {
                camera.position.set(25, 15, 25);
            }
        }
        updateCameraPosition();

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- Orbit Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 15;
        controls.maxDistance = 60;
        controls.maxDistance = 60;
        controls.autoRotate = false; // Disable Camera rotation to decouple stars
        // controls.autoRotateSpeed = 0.8;

        // --- Post-Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, 0.4, 0.85
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Helpers: Noise Texture for Plasma ---
        function createNoiseTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, size, size);

            for (let i = 0; i < 20000; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const w = Math.random() * 30 + 10;
                const h = Math.random() * 30 + 10;
                const alpha = Math.random() * 0.1;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.ellipse(x, y, w, h, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }

            // Blur it for clouds
            // Simplified "fake" cloud noise

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        const plasmaNoise = createNoiseTexture();

        // --- GLOBE CONTAINER ---
        // Rotates independently of the camera/stars
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);

        // --- Objects: 1. Stars (Warp Effect) ---
        let starGeo, starMat, starMesh;
        function createStars() {
            starGeo = new THREE.BufferGeometry();
            const count = 2000; // Reduced count as requested
            const positions = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                // Spread stars in a wide volume but AVOID the center (Globe)
                // We create a "Hollow Cylinder" effect along Z-axis

                // Random angle
                const angle = Math.random() * Math.PI * 2;
                // Radius: 50 to 400 (Safe distance from Globe R=10)
                const radius = 50 + Math.random() * 350;

                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                const z = (Math.random() - 0.5) * 800; // Long Z spread

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }

            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // Bright, fog-ignored stars
            starMat = new THREE.PointsMaterial({
                size: 0.8,
                color: 0xaaddff,
                transparent: true,
                opacity: 0.8,
                fog: false
            });

            starMesh = new THREE.Points(starGeo, starMat);
            return starMesh;
        }
        scene.add(createStars());

        // --- Objects: 2. Core Globe (Dark Matter) ---
        const coreGeo = new THREE.SphereGeometry(9.5, 32, 32);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const core = new THREE.Mesh(coreGeo, coreMat);
        globeGroup.add(core);

        // --- Objects: 3. Hex/Geodesic Shield (Scanning Effect) ---
        // Back to Sphere for "Globe" look
        const shieldGeo = new THREE.SphereGeometry(10, 32, 32);

        // Custom Shader for "Scanning" Shield
        const shieldMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0x00ffff) },
                uScanColor: { value: new THREE.Color(0x39FF14) } // Neon Green
            },
            vertexShader: `
                varying vec3 vPos;
                varying vec2 vUv;
                void main() {
                    vPos = position;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                uniform vec3 uScanColor;
                varying vec3 vPos;

                void main() {
                    // Basic Grid/Wireframe logic is hard in frag shader without barycentric coords.
                    // Instead, we rely on the geometry being drawn as wireframe or use points.
                    // Wait, let's use Three.js WireframeGeometry for lines, and this mesh for "Surface Shield" effect.
                    
                    // Animated Scanline
                    float scan = mod(uTime * 5.0 - vPos.y + 10.0, 20.0);
                    float scanWidth = 2.0;
                    float intensity = 0.0;
                    
                    if (scan < scanWidth) {
                        intensity = 1.0 - smoothstep(0.0, scanWidth, scan);
                    }

                    // Hex-like pattern (fake) using sine waves on position
                    float grid = step(0.98, sin(vPos.x * 2.0) * sin(vPos.y * 2.0) * sin(vPos.z * 2.0));
                    
                    vec3 finalColor = mix(uColor * 0.1, uScanColor, intensity * 0.5);
                    float alpha = 0.1 + intensity * 0.4 + grid * 0.2;
                    
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        // Combine Wireframe and Shader Surface
        const shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
        globeGroup.add(shieldMesh);

        const wireGeo = new THREE.WireframeGeometry(shieldGeo);
        const wireMat = new THREE.LineBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.15 });
        const wireMesh = new THREE.LineSegments(wireGeo, wireMat);
        globeGroup.add(wireMesh);

        // --- Objects: 4. Orbital Rings (Network) ---
        const rings = [];
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });

        function createRing(radius, tube, inclination) {
            const geometry = new THREE.TorusGeometry(radius, tube, 2, 100);
            const mesh = new THREE.Mesh(geometry, ringMat);
            mesh.rotation.x = Math.PI / 2; // Flat
            mesh.rotation.y = inclination;

            // Add a "Data Packet" moving on the ring?
            // Simplified: The ring itself rotates
            globeGroup.add(mesh);
            rings.push({ mesh: mesh, speed: (Math.random() - 0.5) * 2.0, axis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize() });
        }

        createRing(12, 0.05, 0.5);
        createRing(14, 0.03, -0.5);
        createRing(16, 0.02, 0.2);

        // --- Objects: 5. Data Connections (Arcs) ---
        const arcs = [];

        function createArc() {
            // Pick 2 random points on sphere
            const r = 10;
            const p1 = new THREE.Vector3().setFromSphericalCoords(r, Math.acos(2 * Math.random() - 1), 2 * Math.PI * Math.random());
            const p2 = new THREE.Vector3().setFromSphericalCoords(r, Math.acos(2 * Math.random() - 1), 2 * Math.PI * Math.random());

            // Validate distance (don't connect too close or too far)
            if (p1.distanceTo(p2) < 5) return;

            // Bezier Control points (popping out)
            const mid = p1.clone().add(p2).multiplyScalar(0.5).normalize().multiplyScalar(r * 1.5); // 1.5x height

            const curve = new THREE.QuadraticBezierCurve3(p1, mid, p2);
            const pts = curve.getPoints(20);
            const geometry = new THREE.BufferGeometry().setFromPoints(pts);

            // Light Orange for complementary contrast
            const material = new THREE.LineBasicMaterial({ color: 0xFFB366, transparent: true, opacity: 0 });
            const line = new THREE.Line(geometry, material);

            globeGroup.add(line);

            arcs.push({
                line: line,
                life: 0,
                speed: 0.5 + Math.random(),
                maxLife: 100 // frames
            });
        }

        // --- Objects: 6. Surface Markers (Hex Nodes) ---
        const nodes = [];
        const nodeGeo = new THREE.CircleGeometry(0.2, 6);
        const nodeMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        for (let i = 0; i < 20; i++) {
            const mesh = new THREE.Mesh(nodeGeo, nodeMat);
            const r = 10.1; // Just above surface
            const pos = new THREE.Vector3().setFromSphericalCoords(r, Math.acos(2 * Math.random() - 1), 2 * Math.PI * Math.random());
            mesh.position.copy(pos);
            mesh.lookAt(0, 0, 0); // Align to center
            globeGroup.add(mesh);
            nodes.push({ mesh: mesh, blinkOffset: Math.random() * 10 });
        }

        // --- Objects: 7. Solar Flares (Prominences) ---
        const flares = [];
        function createSolarFlare() {
            // 1. Root & Geometry Logic
            const r = 10;
            const theta = Math.acos(2 * Math.random() - 1);
            const phi = 2 * Math.PI * Math.random();
            const p1 = new THREE.Vector3().setFromSphericalCoords(r, theta, phi);

            const offsetTheta = (Math.random() - 0.5) * 0.4;
            const offsetPhi = (Math.random() - 0.5) * 0.4;
            const p2 = new THREE.Vector3().setFromSphericalCoords(r, theta + offsetTheta, phi + offsetPhi);

            const midBase = p1.clone().add(p2).multiplyScalar(0.5).normalize();
            const altitude = 12.5 + Math.random() * 4.5; // Height ~12.5-17 (+30% size)
            const controlSettings = midBase.multiplyScalar(altitude);

            const curve = new THREE.QuadraticBezierCurve3(p1, controlSettings, p2);

            // 2. Volumetric Tube
            // 64 segments for smoothness, radius 0.4 (thick!), 8 radial segments
            const geometry = new THREE.TubeGeometry(curve, 64, 0.11, 8, false);

            // 3. Plasma Shader
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uTexture: { value: plasmaNoise },
                    uColorCore: { value: new THREE.Color(0xFF3300) }, // Deep Orange-Red
                    uColorEdge: { value: new THREE.Color(0xFF8800) }, // Bright Orange
                    uOpacity: { value: 0.0 } // Controlled by JS
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform sampler2D uTexture;
                    uniform vec3 uColorCore;
                    uniform vec3 uColorEdge;
                    uniform float uOpacity;
                    varying vec2 vUv;

                    void main() {
                        // Flow the texture along the tube (vUv.x is length)
                        vec2 flowUv = vec2(vUv.x - uTime * 0.5, vUv.y);
                        float noise = texture2D(uTexture, flowUv).r;
                        
                        // Fire effect: Mix colors based on noise
                        vec3 finalColor = mix(uColorCore, uColorEdge, noise * 1.5);
                        
                        // Edges fade out (Fresnel-ish or just alpha map)
                        // vUv.y is 0..1 around the tube
                        float alpha = uOpacity * (0.5 + noise * 0.5);
                        
                        // Soft edges at ends of tube
                        float edgeFade = smoothstep(0.0, 0.1, vUv.x) * (1.0 - smoothstep(0.9, 1.0, vUv.x));
                        
                        gl_FragColor = vec4(finalColor, alpha * edgeFade);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const mesh = new THREE.Mesh(geometry, material);
            globeGroup.add(mesh);

            flares.push({
                mesh: mesh,
                material: material,
                life: 0,
                maxLife: 150 + Math.random() * 100,
            });
        }


        // --- Animation ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            controls.update();

            // 0. Rotate Globe (Decoupled from Camera)
            globeGroup.rotation.y += 0.002; // Spin speed (was autoRotateSpeed)

            // 1. Animate Shield Shader
            shieldMat.uniforms.uTime.value = time;

            // 2. Animate Rings
            rings.forEach(r => {
                r.mesh.rotateOnAxis(r.axis, r.speed * 0.01);
            });

            // 3. Animate Data Arcs (Spawn and Fade)
            // Increased spawn rate significantly
            if (Math.random() < 0.1) createArc(); // Spawn chance

            for (let i = arcs.length - 1; i >= 0; i--) {
                const a = arcs[i];
                a.life++;

                // Opacity curve: Fade In -> Fade Out
                const progress = a.life / a.maxLife;
                const opacity = Math.sin(progress * Math.PI); // 0 -> 1 -> 0
                a.line.material.opacity = opacity;

                if (a.life > a.maxLife) {
                    globeGroup.remove(a.line);
                    arcs.splice(i, 1);
                }
            }

            // 4. Animate Nodes (Blink)
            nodes.forEach(n => {
                const s = 1 + Math.sin(time * 5 + n.blinkOffset) * 0.5;
                n.mesh.scale.setScalar(s);
            });

            // 5. Animate Solar Flares
            if (Math.random() < 0.05) createSolarFlare();

            for (let i = flares.length - 1; i >= 0; i--) {
                const f = flares[i];
                f.life++;

                // Animate Shader Time (Use f.life or global time)
                if (f.material.uniforms) {
                    f.material.uniforms.uTime.value = time;
                }

                // Opacity curve: Fast In -> Slow Out
                let opacity;
                if (f.life < 30) {
                    // Fade In
                    opacity = f.life / 30;
                } else {
                    // Fade Out
                    opacity = 1 - ((f.life - 30) / (f.maxLife - 30));
                }

                // Update Shader Opacity
                f.material.uniforms.uOpacity.value = Math.max(0, opacity);

                if (f.life > f.maxLife) {
                    globeGroup.remove(f.mesh);
                    f.mesh.geometry.dispose();
                    f.mesh.material.dispose();
                    flares.splice(i, 1);
                }
            }

            // 6. Animate Star Warp (Pass by effect)
            if (starGeo && starGeo.attributes.position) {
                const positions = starGeo.attributes.position.array;
                for (let i = 0; i < 2000; i++) {
                    // Move towards camera (Z+)
                    // Speed increased 30x (0.002 -> 0.06)
                    positions[i * 3 + 2] += 0.06;

                    // Reset if passed camera
                    if (positions[i * 3 + 2] > 400) {
                        positions[i * 3 + 2] = -400;
                    }
                }
                starGeo.attributes.position.needsUpdate = true;
            }

            composer.render();
        }

        // --- Resize Handler ---
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();



            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);

            updateCameraPosition();
        }

        animate();
    </script>
</body>

</html>