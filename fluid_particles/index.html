<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Particle Simulation - Canvas API</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚫</text></svg>">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="instructions">
        Move Cursor to Interact • Click & Hold to Create Black Hole<br>
        <span id="stats" style="font-size:12px; opacity:0.5;">Initializing...</span>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        // --- Configuration ---
        const CONFIG = {
            particleCount: 3500,
            particleRadius: 2,
            neighborhoodRadius: 25, // For collision/interactions
            repulsionForce: 0.5,
            blackHoleForce: 2.0,
            friction: 0.96,
            colors: {
                slow: [10, 10, 30], // Deep Blue/Black
                fast: [0, 255, 200] // Neon Cyan
            }
        };

        // --- Setup Canvas ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimization
        let width, height;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Interaction ---
        const mouse = { x: -1000, y: -1000, down: false };
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);
        // Touch support
        window.addEventListener('touchstart', e => {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
            mouse.down = true;
        });
        window.addEventListener('touchend', () => mouse.down = false);
        window.addEventListener('touchmove', e => {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
        });


        // --- Spatial Hash Grid Optimization ---
        // Efficient way to find neighbors without O(N^2) checks
        class SpatialGrid {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }

            clear() {
                this.grid.clear();
            }

            getKey(x, y) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                return `${gx},${gy}`;
            }

            insert(particle) {
                const key = this.getKey(particle.x, particle.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(particle);
            }

            // Get particles from current cell and 8 neighbors
            getNeighbors(particle) {
                const neighbors = [];
                const gx = Math.floor(particle.x / this.cellSize);
                const gy = Math.floor(particle.y / this.cellSize);

                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const key = `${gx + i},${gy + j}`;
                        if (this.grid.has(key)) {
                            const cellParticles = this.grid.get(key);
                            for (let k = 0; k < cellParticles.length; k++) {
                                neighbors.push(cellParticles[k]);
                            }
                        }
                    }
                }
                return neighbors;
            }
        }

        const grid = new SpatialGrid(CONFIG.neighborhoodRadius);


        // --- Particle System ---
        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.radius = Math.random() * 1.5 + 1;
            }

            update() {
                // 1. Mouse Interaction
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distSq = dx * dx + dy * dy;
                const dist = Math.sqrt(distSq);

                if (mouse.down) {
                    // Black hole (Attraction)
                    if (dist > 10) { // Don't collapse completely
                        const force = CONFIG.blackHoleForce * 1000 / distSq;
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                } else {
                    // Repulsion (Fluid-like dispersion from cursor)
                    if (dist < 200) {
                        const force = (200 - dist) / 200; // 0 to 1
                        this.vx -= (dx / dist) * force * 2; // Push away
                        this.vy -= (dy / dist) * force * 2;
                    }
                }

                // 2. Neighbor Interaction (Collision/Separation) via Grid
                const neighbors = grid.getNeighbors(this);
                let count = 0;

                for (let other of neighbors) {
                    if (other === this) continue;

                    const ndx = this.x - other.x;
                    const ndy = this.y - other.y;
                    const ndistSq = ndx * ndx + ndy * ndy;

                    // Separation (Fluid density constraint)
                    const minDist = CONFIG.particleRadius * 4;
                    if (ndistSq > 0 && ndistSq < minDist * minDist) {
                        const ndist = Math.sqrt(ndistSq);
                        const force = (minDist - ndist) / minDist;

                        // Apply separate force
                        const fx = (ndx / ndist) * force * 0.5;
                        const fy = (ndy / ndist) * force * 0.5;

                        this.vx += fx;
                        this.vy += fy;
                        count++;
                    }
                }

                // 3. Physics Integration
                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;

                this.x += this.vx;
                this.y += this.vy;

                // 4. Boundary Wrap/Bounce
                if (this.x < 0) { this.x = 0; this.vx *= -1; }
                if (this.x > width) { this.x = width; this.vx *= -1; }
                if (this.y < 0) { this.y = 0; this.vy *= -1; }
                if (this.y > height) { this.y = height; this.vy *= -1; }
            }

            draw(ctx) {
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const t = Math.min(speed / 10, 1); // 0 to 1 based on speed

                // Simple Heatmap / Gradient Color
                // Blue (Slow) -> Cyan/Green (Fast) -> White (Very Fast)

                if (t < 0.1) {
                    ctx.fillStyle = `rgba(30, 60, 100, 0.5)`;
                } else {
                    // HSL Transition
                    // Hue: 200 (Blue) -> 140 (Green) -> 60 (Yellow)
                    const hue = 200 - (t * 100);
                    const lightness = 30 + (t * 40);
                    ctx.fillStyle = `hsla(${hue}, 100%, ${lightness}%, 0.8)`;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Sound Manager (Underwater Physics) ---
        const SoundManager = {
            ctx: null,
            ambientNode: null, // { source, filter, gain }
            isBlackHolePlaying: false,
            blackHoleNode: null,

            init: function () {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.startAmbient();
            },

            createOsc: function (type, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                return osc;
            },

            createGain: function (val) {
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(val, this.ctx.currentTime);
                return gain;
            },

            // 1. Ambient (Deep Water Rumble)
            startAmbient: function () {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 2; // 2 sec loop
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02; // Pink Noise approx
                    lastOut = data[i];
                    data[i] *= 3.5;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200; // Deep rumble start

                const gain = this.ctx.createGain();
                gain.gain.value = 0.5;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();

                this.ambientNode = { source: noise, filter: filter, gain: gain };
            },

            // 2. Physics Sync (Modulate Ambient)
            updatePhysics: function (totalSpeed) {
                if (!this.ctx || !this.ambientNode) return;
                // totalSpeed ranges roughly 0 to (3500 * 2) = 7000?
                // Map to 200Hz - 1000Hz
                let targetFreq = 200 + (totalSpeed / 10);
                if (targetFreq > 1200) targetFreq = 1200;

                // Smooth transition
                this.ambientNode.filter.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1);
            },

            // 4. Black Hole (Deep Vacuum Drone)
            startBlackHole: function () {
                if (!this.ctx || this.isBlackHolePlaying) return;
                this.isBlackHolePlaying = true;
                const t = this.ctx.currentTime;

                // Layer 1: Deep Sine Drone
                const osc1 = this.createOsc('sine', 45);
                const gain1 = this.createGain(0);

                // Layer 2: Sub Bass (Detuned for beating/width)
                const osc2 = this.createOsc('sine', 35); // 35Hz Sub
                const gain2 = this.createGain(0);

                // Layer 3: Vacuum Noise (Filtered Wind)
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1; // White noise
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;

                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.value = 100;
                const noiseGain = this.createGain(0);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                noise.start(t);

                // LFO for throbbing
                const lfo = this.createOsc('sine', 3); // Starts at 3Hz
                const lfoGain = this.createGain(10);
                lfo.connect(lfoGain);
                lfoGain.connect(osc1.frequency);
                lfo.start(t);

                osc1.connect(gain1);
                gain1.connect(this.ctx.destination);
                osc1.start(t);

                osc2.connect(gain2);
                gain2.connect(this.ctx.destination);
                osc2.start(t);

                // --- Dynamic Ramp Logic ---
                // 0s - 0.5s: Fade in to base level
                gain1.gain.setValueAtTime(0, t);
                gain1.gain.linearRampToValueAtTime(0.3, t + 0.5);

                gain2.gain.setValueAtTime(0, t);
                gain2.gain.linearRampToValueAtTime(0.4, t + 0.5);

                noiseGain.gain.setValueAtTime(0, t);
                noiseGain.gain.linearRampToValueAtTime(0.1, t + 0.5);

                // 1s - 3s: Ramp to Maximum Intensity
                const rampStart = t + 1.0;
                const rampEnd = t + 3.0;

                gain1.gain.setValueAtTime(0.3, rampStart);
                gain1.gain.exponentialRampToValueAtTime(0.8, rampEnd); // Peak Drone

                gain2.gain.setValueAtTime(0.4, rampStart);
                gain2.gain.exponentialRampToValueAtTime(1.0, rampEnd); // Peak Sub

                noiseGain.gain.setValueAtTime(0.1, rampStart);
                noiseGain.gain.exponentialRampToValueAtTime(0.6, rampEnd); // Peak Vacuum

                noiseFilter.frequency.setValueAtTime(100, rampStart);
                noiseFilter.frequency.linearRampToValueAtTime(800, rampEnd); // Filter opens wide

                lfo.frequency.setValueAtTime(3, rampStart);
                lfo.frequency.linearRampToValueAtTime(15, rampEnd); // Shudder speeds up

                this.blackHoleNode = { osc1, gain1, osc2, gain2, noise, noiseFilter, noiseGain, lfo, lfoGain };
            },

            stopBlackHole: function () {
                if (!this.ctx || !this.isBlackHolePlaying || !this.blackHoleNode) return;
                const t = this.ctx.currentTime;

                // Trigger End Explosion
                this.playEndExplosion();

                // Quick cut off (absorbed by explosion)
                const release = 0.1;
                this.blackHoleNode.gain1.gain.setTargetAtTime(0, t, release);
                this.blackHoleNode.gain2.gain.setTargetAtTime(0, t, release);
                this.blackHoleNode.noiseGain.gain.setTargetAtTime(0, t, release);

                // Ramp pitch down slightly for "Power Down" feel
                this.blackHoleNode.osc1.frequency.exponentialRampToValueAtTime(10, t + 0.2);
                this.blackHoleNode.osc2.frequency.exponentialRampToValueAtTime(10, t + 0.2);

                const stopTime = t + 0.2;
                this.blackHoleNode.osc1.stop(stopTime);
                this.blackHoleNode.osc2.stop(stopTime);
                this.blackHoleNode.noise.stop(stopTime);
                this.blackHoleNode.lfo.stop(stopTime);

                this.isBlackHolePlaying = false;
                this.blackHoleNode = null;
            },

            playEndExplosion: function () {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                // 1. Noise Burst (Release valve / Splash)
                const bufSize = this.ctx.sampleRate * 1.5;
                const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const nFilter = this.ctx.createBiquadFilter();
                nFilter.type = 'lowpass';
                nFilter.frequency.setValueAtTime(800, t);
                nFilter.frequency.exponentialRampToValueAtTime(50, t + 0.8);

                const nGain = this.ctx.createGain();
                nGain.gain.setValueAtTime(0.8, t);
                nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);

                noise.connect(nFilter);
                nFilter.connect(nGain);
                nGain.connect(this.ctx.destination);
                noise.start(t);

                // 2. Sub Impact (Boom)
                const osc = this.createOsc('sine', 60);
                const oGain = this.createGain(1.0);

                osc.frequency.setValueAtTime(60, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);

                oGain.gain.setValueAtTime(1.0, t);
                oGain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);

                osc.connect(oGain);
                oGain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 1.0);
            },

            // 3. Disturbance (Swish)
            playDisturbance: function (force) {
                if (!this.ctx) return;
                if (force < 5) return; // Ignore small moves

                const t = this.ctx.currentTime;
                const gain = this.createGain(0.1);

                // Bandpass sweep for "Swish"
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.Q.value = 1;
                filter.frequency.setValueAtTime(200, t);
                filter.frequency.linearRampToValueAtTime(800, t + 0.1);

                // Noise for texture
                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start(t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5); // Quick fade out
                noise.stop(t + 0.5);
            }
        };

        // UI & Audio Hooks
        const audioStatus = document.createElement('div');
        audioStatus.style.cssText = 'position:fixed;bottom:20px;right:20px;font-family:"Inter", sans-serif;font-size:12px;color:rgba(255,255,255,0.5);pointer-events:none;';
        audioStatus.innerText = 'AUDIO: SILENT [CLICK TO START]';
        document.body.appendChild(audioStatus);

        const initAudio = () => {
            if (!SoundManager.ctx) {
                SoundManager.init();
                audioStatus.innerText = 'AUDIO: ACTIVE';
                audioStatus.style.color = '#0ff';
                audioStatus.style.textShadow = '0 0 10px #0ff';
            } else if (SoundManager.ctx.state === 'suspended') {
                SoundManager.ctx.resume();
            }
        };

        window.addEventListener('mousedown', () => { initAudio(); SoundManager.startBlackHole(); });
        window.addEventListener('mouseup', () => SoundManager.stopBlackHole());
        window.addEventListener('touchstart', () => { initAudio(); SoundManager.startBlackHole(); });
        window.addEventListener('touchend', () => SoundManager.stopBlackHole());

        window.addEventListener('mousemove', e => {
            if (SoundManager.ctx) {
                const speed = Math.sqrt(e.movementX ** 2 + e.movementY ** 2);
                SoundManager.playDisturbance(speed);
            }
        });
        const particles = Array.from({ length: CONFIG.particleCount }, () => new Particle());
        const statsEl = document.getElementById('stats');
        let lastTime = 0;

        function animate(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;

            // Clear Screen with trailing effect
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; // Trail
            ctx.fillRect(0, 0, width, height);

            // 1. Build Spatial Grid for this frame
            grid.clear();
            for (let p of particles) {
                grid.insert(p);
            }

            // 2. Update and Draw
            let totalEnergy = 0;
            for (let p of particles) {
                p.update();
                p.draw(ctx);

                // Audio Physics Sync
                totalEnergy += (Math.abs(p.vx) + Math.abs(p.vy));
            }
            if (SoundManager.ctx) SoundManager.updatePhysics(totalEnergy);

            // Stats
            if (timestamp % 1000 < 20) {
                const fps = Math.round(1000 / dt);
                statsEl.innerText = `${particles.length} Particles | ${fps} FPS`;
            }

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

    </script>
</body>

</html>