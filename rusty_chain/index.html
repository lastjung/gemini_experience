<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rusty Chain Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #222;
            /* Dark, rusty background */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            /* Left aligned */
            padding: 15px;
            /* Transparent Background as requested */
            background: rgba(0, 0, 0, 0);
            border: none;
            z-index: 1000;
            width: 220px;
            color: #eceff1;
            /* Force Light Text Color */
        }

        h1 {
            margin: 0 0 5px 0;
            font-size: 20px;
            color: #eceff1;
            /* Force Light Text Color */
        }

        p {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #cfd8dc;
            /* Slightly dimmer white */
        }

        button {
            pointer-events: auto;
            background: #8d6e63;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: background 0.2s, transform 0.1s;
        }

        button:hover {
            background: #a1887f;
        }

        button:active {
            transform: translateY(1px);
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <h1>Rusty Chain</h1>
        <p>Drag the chain. Smash the boxes.</p>
        <button onclick="simulation.reset()">Reset Scene</button>
        <div class="slider-container" style="margin-top: 15px;">
            <label for="frictionSlider"
                style="color: #efebe9; font-family: 'Courier New', monospace; font-size: 14px;">Friction: <span
                    id="frictionVal">0.9</span></label>
            <input type="range" id="frictionSlider" min="0.1" max="1.0" step="0.1" value="0.9"
                style="width: 100%; margin-top: 5px;">
        </div>
        <div class="slider-container" style="margin-top: 10px;">
            <label for="restitutionSlider" style="font-family: 'Courier New', monospace; font-size: 14px;">Elasticity:
                <span id="restitutionVal">0.0</span></label>
            <input type="range" id="restitutionSlider" min="0.0" max="1.0" step="0.1" value="0.0"
                style="width: 100%; margin-top: 5px;">
        </div>
        <div id="audio-status" style="margin-top: 15px; font-size: 12px; color: #ff5252;">AUDIO: OFF (CLICK SCREEN)
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- Rusty Chain Simulation V2 (Unified Architecture) ---

        const Simulation = function () {
            // Module Aliases
            const Engine = Matter.Engine,
                Render = Matter.Render,
                Runner = Matter.Runner,
                Composite = Matter.Composite,
                Composites = Matter.Composites,
                Common = Matter.Common,
                MouseConstraint = Matter.MouseConstraint,
                Mouse = Matter.Mouse,
                World = Matter.World,
                Bodies = Matter.Bodies,
                Body = Matter.Body,
                Sleeping = Matter.Sleeping, // Added Sleeping module
                Events = Matter.Events,     // Added Events module 
                Constraint = Matter.Constraint;

            // Core Objects
            let engine, render, runner;
            let mouseConstraint; // Defined at module level to persist across resets
            let width, height;
            let isMobile;

            // --- Sound Manager (Web Audio API) ---
            // Moved to Module Scope to be accessible by all functions (init, reset, setupEvents)
            const SoundManager = {
                ctx: null,
                isMuted: false,

                init: function () {
                    const statusEl = document.getElementById('audio-status');

                    if (!this.ctx) {
                        window.AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.ctx = new AudioContext();
                    }

                    // Force Resume (Standard Browser Fix)
                    if (this.ctx.state === 'suspended') {
                        this.ctx.resume().then(() => {
                            console.log("Audio Context Resumed");
                            statusEl.innerText = "AUDIO: ACTIVE";
                            statusEl.style.color = "#00e676";
                        });
                    } else {
                        statusEl.innerText = "AUDIO: ACTIVE";
                        statusEl.style.color = "#00e676";
                    }
                },

                createOsc: function (type, freq) {
                    const osc = this.ctx.createOscillator();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    return osc;
                },

                createGain: function (val) {
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(val, this.ctx.currentTime);
                    return gain;
                },

                // 1. Heavy Box Impact (Thud)
                playImpact: function (intensity) {
                    if (!this.ctx || this.isMuted) return;
                    if (intensity < 0.5) return;

                    const t = this.ctx.currentTime;
                    const osc = this.createOsc('triangle', 60 - Math.random() * 20);
                    const gain = this.createGain(0);

                    osc.connect(gain);
                    gain.connect(this.ctx.destination);

                    const volume = Math.min(intensity * 0.2, 0.8);

                    osc.start(t);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(volume, t + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                    osc.stop(t + 0.2);
                },

                // 2. Metallic Chain Sound (Clang)
                playMetal: function (intensity) {
                    if (!this.ctx || this.isMuted) return;
                    if (intensity < 1.0) return;

                    const t = this.ctx.currentTime;
                    // Lower frequencies for heavy iron chain (Heavy Clank)
                    const freqs = [150, 200, 250, 300];
                    // Mixed Sawtooth for "gritty" rust sound
                    const osc = this.createOsc('sawtooth', freqs[Math.floor(Math.random() * freqs.length)]);
                    const gain = this.createGain(0);

                    // Lowpass filter to muffle the harshness
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 800;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.ctx.destination);

                    const volume = Math.min(intensity * 0.05, 0.2); // Slightly quieter for lower tones

                    osc.start(t);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(volume, t + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                    osc.stop(t + 0.3);
                }
            };

            // CONFIGURATION
            const COLORS = {
                background: '#1a1a1a',             // Dark industrial background
                wall: '#3e2723',                   // Dark wood/rust color
                chainInfo: { fill: '#8d6e63', stroke: '#5d4037' }, // Rusty metal
                ball: { fill: '#5d4037', stroke: '#3e2723' },     // Heavy iron
                box: { fill: '#d7ccc8', stroke: '#a1887f' }       // Old wood
            };

            const PHYSICS = {
                chainDensity: 0.02,    // Tuned: Heavy enough to crush, light enough to drag
                ballDensity: 0.05,     // Tuned: 10x heavier than boxes (was 40x), draggable
                boxDensity: 0.005,    // Light, breakable
                wallFriction: 1.0     // Grip
            };

            // Init Function - The Entry Point
            function init() {
                // 1. Create Engine
                engine = Engine.create();

                // 2. Create Renderer (Preliminary dimensions, reset() will update)
                const container = document.getElementById('canvas-container');
                render = Render.create({
                    element: container,
                    engine: engine,
                    options: {
                        width: window.innerWidth,
                        height: window.innerHeight,
                        background: COLORS.background,
                        wireframes: false,
                        showAngleIndicator: false
                    }
                });

                // 3. Create Runner
                runner = Runner.create();
                Render.run(render);
                Runner.run(runner, engine);

                // Global Audio Init
                const handleInteraction = () => { SoundManager.init(); };
                ['mousedown', 'touchstart', 'keydown'].forEach(evt =>
                    document.addEventListener(evt, handleInteraction)
                );

                // 4. Interaction (Constraint creation)
                setupInteraction();

                // 5. Events
                setupEvents();

                // 6. Build Scene (This sets width/height and creates objects)
                reset();
            }

            // --- Event Logic (Consolidated) ---
            function setupEvents() {
                // 0. Interaction Audio Resume (Best for Iframes/Matter.js)
                if (mouseConstraint) {
                    Events.on(mouseConstraint, 'mousedown', function () {
                        SoundManager.init();
                    });
                }

                // 1. Audio + Wake Logic (Collision)
                Events.on(engine, 'collisionStart', function (event) {
                    // Try to resume if collision happens (rarely works without input, but good fallback)
                    if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
                        SoundManager.ctx.resume();
                    }
                    const pairs = event.pairs;

                    for (let i = 0; i < pairs.length; i++) {
                        const pair = pairs[i];
                        const bodyA = pair.bodyA;
                        const bodyB = pair.bodyB;

                        const speedA = bodyA.speed;
                        const speedB = bodyB.speed;
                        const intensity = speedA + speedB;

                        // Audio Triggers
                        if (intensity > 0.5) {
                            const isMetal = (bodyA.label === 'Circle Body' || bodyB.label === 'Circle Body') ||
                                (bodyA.label === 'rect' || bodyB.label === 'rect');

                            const isBox = bodyA.label === 'destructibleBox' || bodyB.label === 'destructibleBox';

                            if (isMetal && isBox) {
                                SoundManager.playImpact(intensity); // Heavy hit
                            } else if (isMetal && !isBox) {
                                SoundManager.playMetal(intensity); // Chain clatter
                            } else if (isBox && isBox && intensity > 2) {
                                SoundManager.playImpact(intensity * 0.5); // Box on Box
                            }
                        }

                        // Sleeping Giant Logic: Wake up boxes on first touch
                        // If a box touches something dynamic, wake ALL boxes
                        if (bodyA.label === 'destructibleBox' || bodyB.label === 'destructibleBox') {
                            activateBoxes();
                        }
                    }
                });

                // 2. Slider Listeners
                const slider = document.getElementById('frictionSlider');
                const label = document.getElementById('frictionVal');
                if (slider) {
                    slider.addEventListener('input', function (e) {
                        const val = parseFloat(e.target.value);
                        label.innerText = val.toFixed(1);
                        const allBodies = Composite.allBodies(engine.world);
                        allBodies.forEach(body => {
                            if (!body.isStatic && body.label !== 'Circle Body') {
                                body.friction = val;
                            }
                        });
                    });
                }

                const rSlider = document.getElementById('restitutionSlider');
                const rLabel = document.getElementById('restitutionVal');
                if (rSlider) {
                    rSlider.addEventListener('input', function (e) {
                        const val = parseFloat(e.target.value);
                        rLabel.innerText = val.toFixed(1);
                        const allBodies = Composite.allBodies(engine.world);
                        allBodies.forEach(body => {
                            if (!body.isStatic && body.label !== 'Circle Body') {
                                body.restitution = val;
                            }
                        });
                    });
                }
            }

            // --- Scene Building Logic ---

            function reset() {
                // 1. Clear World immediately
                World.clear(engine.world);
                Engine.clear(engine);

                // 2. Update Dimensions
                width = window.innerWidth;
                height = window.innerHeight;

                // FIX: MacBook Air detection
                // Previous check (width < 768) misidentifies high-res desktops or zoomed browsers.
                // Added `navigator.maxTouchPoints > 0` to ensure physical touch capability.
                isMobile = (width < 768) && (navigator.maxTouchPoints > 0);

                // 3. Update Renderer Size
                render.canvas.width = width;
                render.canvas.height = height;
                render.options.width = width;
                render.options.height = height;

                // 4. Rebuild Static Boundaries
                createBoundaries();
                createChainAndBall();
                createBoxStack();

                // 6. Touch-to-Wake ("Sleeping Giant")
                // No timer. We wait for collision listener to trigger activateBoxes().
                // Boxes spawn isStatic: true and stay that way until touched.

                // 7. Restore Interaction
                // World.clear() removed the constraint, so we must add it back.
                if (mouseConstraint) {
                    Composite.add(engine.world, mouseConstraint);
                }
            }

            function createBoundaries() {
                const wallThick = 60;
                const groundY = height + wallThick / 2; // Ensure floor is just at bottom edge

                // Ground
                const ground = Bodies.rectangle(width / 2, height + 30, width * 2, 60 + 60, { // Extra thick + offset to be flush
                    isStatic: true,
                    render: { fillStyle: COLORS.wall },
                    friction: 1.0
                });

                // Walls (Invisible buffers logic if needed, but here we explicitly draw them)
                // Right Wall
                const rightWall = Bodies.rectangle(width + 30, height / 2, 60, height * 2, {
                    isStatic: true, render: { visible: false }
                });

                // Left Wall
                const leftWall = Bodies.rectangle(-30, height / 2, 60, height * 2, {
                    isStatic: true, render: { visible: false }
                });

                Composite.add(engine.world, [ground, rightWall, leftWall]);
            }

            function createChainAndBall() {
                const group = Body.nextGroup(true);

                // Mobile Calibration
                const ballRadius = isMobile ? 22 : 40;  // 22px on mobile, 40px desktop
                const linkW = isMobile ? 35 : 50;
                const linkH = isMobile ? 15 : 20;
                const chainLengthPct = 0.70; // INCREASED: 55% -> 70% of screen height

                const chainCount = Math.floor((height * chainLengthPct) / (linkH * 1.1));

                // 1. Create Chain Stack
                const chainX = width / 2;
                const chainY = height * 0.1;

                const chain = Composites.stack(chainX, chainY, 1, chainCount, 0, 0, function (x, y) {
                    return Bodies.rectangle(x, y, linkW, linkH, {
                        collisionFilter: { group: group },
                        density: PHYSICS.chainDensity,
                        frictionAir: 0.005,
                        chamfer: { radius: isMobile ? 3 : 5 },
                        render: {
                            fillStyle: COLORS.chainInfo.fill,
                            strokeStyle: COLORS.chainInfo.stroke,
                            lineWidth: 2
                        }
                    });
                });

                // 2. Connect Links
                Composites.chain(chain, 0, 0.4, 0, -0.4, {
                    stiffness: 0.9,
                    length: 0,
                    render: { visible: false }
                });

                // 3. Anchor Top
                const anchor = Constraint.create({
                    bodyB: chain.bodies[0],
                    pointB: { x: 0, y: -linkH * 0.4 },
                    pointA: { x: chainX, y: chainY },
                    stiffness: 0.9,
                    render: { strokeStyle: '#888', lineWidth: 4 }
                });

                // 4. Wrecking Ball
                const lastLink = chain.bodies[chain.bodies.length - 1];
                const ballY = lastLink.position.y + linkH + ballRadius;

                const ball = Bodies.circle(chainX, ballY, ballRadius, {
                    density: PHYSICS.ballDensity,
                    friction: 0.5,
                    restitution: 0, // No bounce, just heavy impact
                    render: {
                        fillStyle: COLORS.ball.fill,
                        strokeStyle: COLORS.ball.stroke,
                        lineWidth: 3
                    }
                });

                // 5. Connect Ball to Chain
                const ballConnect = Constraint.create({
                    bodyA: lastLink,
                    bodyB: ball,
                    pointA: { x: 0, y: linkH * 0.4 },
                    pointB: { x: 0, y: -ballRadius }, // Top of ball
                    stiffness: 0.9,
                    length: 5,
                    render: { strokeStyle: '#3e2723', lineWidth: 4 }
                });

                Composite.add(engine.world, [chain, anchor, ball, ballConnect]);
            }

            function activateBoxes() {
                // "Silent Descent" Activation
                // Find all boxes (marked with label 'destructibleBox') and unfreeze them.
                const allBodies = Composite.allBodies(engine.world);
                allBodies.forEach(body => {
                    if (body.label === 'destructibleBox') {
                        Body.setStatic(body, false); // Unlock physics
                        Sleeping.set(body, false);   // Ensure they are awake
                    }
                });
            }

            function createBoxStack() {
                // Mobile Calibration
                const boxS = isMobile ? 30 : 45; // Size
                const cols = isMobile ? 3 : 6;   // 3 Cols for mobile
                const rows = isMobile ? 20 : 14;  // INCREASED: 12 -> 14 for desktop
                const gap = 0; // ZERO GAP as requested

                // Safe Zone Calculation


                const rightEdge = width * 0.95;
                const stackW = cols * (boxS + gap);

                // Ensure stack is safely on the right but not clipping
                const startX = rightEdge - stackW - (isMobile ? 15 : 50);
                // Ground Top is at (height - 30).
                // CORRECT FORMULA: startY needs to account for the box center (boxS/2).
                // Subtracting rows of boxes from the ground.
                // startY = GroundY - (boxS/2) - ((rows-1)*(boxS+gap))
                // Exact math used here. Removed offset to prevent "ejection"
                const startY = (height - 30) - (boxS / 2) - ((rows - 1) * (boxS + gap));

                const stack = Composites.stack(startX, startY, cols, rows, gap, gap, function (x, y) {
                    return Bodies.rectangle(x, y, boxS, boxS, {
                        label: 'destructibleBox', // Label for activation targeting
                        density: PHYSICS.boxDensity,
                        friction: parseFloat(document.getElementById('frictionSlider').value), // Use current slider value
                        frictionStatic: 10.0, // Keep static high for stability
                        restitution: parseFloat(document.getElementById('restitutionSlider').value), // Bounciness
                        isStatic: true,   // STATIC SPAWN: Pinned in space initially
                        isSleeping: true, // Also sleeping, just in case
                        chamfer: { radius: 2 },
                        render: {
                            fillStyle: COLORS.box.fill,
                            strokeStyle: COLORS.box.stroke,
                            lineWidth: 1
                        }
                    });
                });

                Composite.add(engine.world, stack);
            }

            function setupInteraction() {
                const mouse = Mouse.create(render.canvas);

                // REVERT: pixelRatio setting caused interaction issues on some devices.
                // Matter.js Render module usually handles this automatically.
                // Reverted to standard setup.

                // Assign to module-level variable
                mouseConstraint = MouseConstraint.create(engine, {
                    mouse: mouse,
                    constraint: {
                        stiffness: 0.5, // BALANCED GRIP: 0.5 offers tight control without jitter
                        damping: 0.1,   // Slight damping to prevent jitter
                        angularStiffness: 0.9,
                        render: { visible: false } // Verified: Mouse is working, hiding debug line
                    }
                });

                // Scale touch inputs correctly
                render.mouse = mouse;

                Composite.add(engine.world, mouseConstraint);
            }

            function handleResize() {
                // Debounce simple reset
                reset();
            }

            // Expose Public API
            return {
                init: init,
                reset: reset
            };

        }();

        // Start Simulation
        window.addEventListener('load', function () {
            simulation = Simulation;
            simulation.init();
        });

    </script>
</body>

</html>